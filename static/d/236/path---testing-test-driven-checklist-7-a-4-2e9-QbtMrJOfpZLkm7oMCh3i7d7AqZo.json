{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/agile","title":"Agile"}}},{"node":{"frontmatter":{"path":"/agile/bugs","title":"Bugs"}}},{"node":{"frontmatter":{"path":"/agile/confluence","title":"Confluence"}}},{"node":{"frontmatter":{"path":"/agile/jira","title":"Jira"}}},{"node":{"frontmatter":{"path":"/people","title":"People"}}},{"node":{"frontmatter":{"path":"/conventions","title":"Conventions Used"}}},{"node":{"frontmatter":{"path":"/operational-exellence/ceremonies","title":"Ceremonies"}}},{"node":{"frontmatter":{"path":"/operational-exellence/guilds","title":"Guilds"}}},{"node":{"frontmatter":{"path":"/operational-exellence/standups","title":"Stand-ups"}}},{"node":{"frontmatter":{"path":"/operational-exellence","title":"Operational Excellence"}}},{"node":{"frontmatter":{"path":"/security/credentials","title":"Credentials"}}},{"node":{"frontmatter":{"path":"/security/secure-code","title":"Secure Code Standards"}}},{"node":{"frontmatter":{"path":"/security","title":"Security"}}},{"node":{"frontmatter":{"path":"/security/security-training","title":"Security training"}}},{"node":{"frontmatter":{"path":"/security/software-composition","title":"Software Composition Analysis"}}},{"node":{"frontmatter":{"path":"/security/static-code","title":"Static Code Analysis"}}},{"node":{"frontmatter":{"path":"/principles","title":"Principles"}}},{"node":{"frontmatter":{"path":"/software-eng-checklist","title":"Software Engineering Checklist"}}},{"node":{"frontmatter":{"path":"/standards/api-standards","title":"API Standards"}}},{"node":{"frontmatter":{"path":"/standards/ci-cd","title":"CI/CD"}}},{"node":{"frontmatter":{"path":"/standards/cloud","title":"Cloud"}}},{"node":{"frontmatter":{"path":"/standards/code-review","title":"Code Review/Pull Requests"}}},{"node":{"frontmatter":{"path":"/standards/code-style","title":"Code Style"}}},{"node":{"frontmatter":{"path":"/standards/definitions","title":"Definitions of Done"}}},{"node":{"frontmatter":{"path":"/standards/design-principles","title":"Design Principles"}}},{"node":{"frontmatter":{"path":"/standards/logging","title":"Logging"}}},{"node":{"frontmatter":{"path":"/standards/readme","title":"README"}}},{"node":{"frontmatter":{"path":"/standards/ready","title":"Definitions of Ready"}}},{"node":{"frontmatter":{"path":"/standards","title":"Standards"}}},{"node":{"frontmatter":{"path":"/standards/design-review","title":"Technical Design Review"}}},{"node":{"frontmatter":{"path":"/standards/version-control","title":"Version Control"}}},{"node":{"frontmatter":{"path":"/standards/versioning","title":"Versioning"}}},{"node":{"frontmatter":{"path":"/testing/characteristics","title":"Characteristics of a Good Unit Test"}}},{"node":{"frontmatter":{"path":"/testing/test-data","title":"Test Data"}}},{"node":{"frontmatter":{"path":"/testing/test-driven-checklist","title":"Test-Driven Development Checklist"}}},{"node":{"frontmatter":{"path":"/testing/test-driven-development","title":"Test-Driven Development"}}},{"node":{"frontmatter":{"path":"/testing","title":"Testing"}}}]},"markdownRemark":{"html":"<h1>Test-Driven Development Checklist</h1>\n<p>TDD is described by a basic red-green-refactor cycle, constantly\nrepeated to add new features or fix bugs.</p>\n<p><strong>Red</strong><br>\nThe development of every new feature should start with a failing test.</p>\n<ul>\n<li>\n<p>Have you checked in the code in your remote or local repository? In</p>\n<blockquote>\n<p>case the code breaks, a revert is faster than a rewrite.</p>\n</blockquote>\n</li>\n<li>\n<p>Have you already written some production code? If so, comment it or</p>\n<blockquote>\n<p>(best) delete it to not be implicitly tied to an Api while writing\nthe test.</p>\n</blockquote>\n</li>\n<li>\n<p>Have you chosen the right unit to expand? The modified class should</p>\n<blockquote>\n<p>be the one that remains more cohesive after the change, and often\nin new classes should be introduced instead of accommodating\nfunctionalities in existing ones.</p>\n</blockquote>\n</li>\n<li>\n<p>Does the test fail? If not, rewrite the test to expose the lack of</p>\n<blockquote>\n<p>functionality.</p>\n</blockquote>\n</li>\n<li>\n<p>Does a subset of the test already fail? Is so, you can remove the</p>\n<blockquote>\n<p>surplus part of the test, avoiding verbosity; it can come back in\ndifferent test methods.</p>\n</blockquote>\n</li>\n<li>\n<p>Does the test prescribe overly specific assertions or expectations?</p>\n<blockquote>\n<p>If so, lessen the mock expectations by not checking method calls\norder or how many times a method is called; improve the assertions\nby substituting equality matches with matches over properties of\nthe result object.</p>\n</blockquote>\n</li>\n<li>\n<p>Does the test name describe its intent? Make sure it is not tied to</p>\n<blockquote>\n<p>implementation details and works as low-level documentation.</p>\n</blockquote>\n</li>\n<li>\n<p>How much can you change in an hypothetical implementation without</p>\n<blockquote>\n<p>breaking the test (making it brittle)?</p>\n</blockquote>\n</li>\n<li>\n<p>Is the failure message expressive about what is broken? Make sure it</p>\n<blockquote>\n<p>describes where the failing functionality resides, highlighting\nthe right location if it breaks in the future.</p>\n</blockquote>\n</li>\n<li>\n<p>Are magic numbers and strings expressed as constants? Is there</p>\n<blockquote>\n<p>repeated code? Test code refactoring is easy when done early and\nwhile a test fails, since in this paradigm it is more important to\nkeep it failing then to keep it passing.</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Green</strong><br>\nEnough production code should be written to make the test pass.</p>\n<ul>\n<li>\n<p>Does the production code make the test pass? (Plainly obvious)</p>\n</li>\n<li>\n<p>Does a subset of the production code make the test pass? If so, you</p>\n<blockquote>\n<p>can comment or (best) remove the unnecessary production code. Any\nmore lines you write are untested lines you'll have to read and\nmaintain in the future.</p>\n</blockquote>\n</li>\n<li>\n<p>Every other specific action will be taken in the Refactor phase.</p>\n</li>\n</ul>\n<p><strong>Refactor</strong><br>\nImprove the structure of the code to ease future changes and\nmaintenance.</p>\n<ul>\n<li>\n<p>Does repeated code exist in the current class?</p>\n</li>\n<li>\n<p>Is the name of the class under test appropriate?</p>\n</li>\n<li>\n<p>Do the public and protected method names describe their intent? Are</p>\n<blockquote>\n<p>they readable? <em>Rename</em> refactorings are between the most powerful\nones.</p>\n</blockquote>\n</li>\n<li>\n<p>Does repeated code exist in different classes? Is there a missing</p>\n<blockquote>\n<p>domain concept? You can extract abstract classes or refactor\ntowards composition. At this high-level the refactoring should be\nalso applied to the unit tests, and there are many orthogonal\ntechniques you can apply so I won't describe them all here..</p>\n</blockquote>\n</li>\n</ul>\n<p>Reference:\n<a href=\"https://www.giorgiosironi.com/2010/03/tdd-checklist-red-green-refactor-in.html\">https://www.giorgiosironi.com/2010/03/tdd-checklist-red-green-refactor-in.html</a></p>","frontmatter":{"title":"Test-Driven Development Checklist","path":"/testing/test-driven-checklist"}}},"pageContext":{"section":"playbook"}}