{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"path":"/people","title":"People"}}},{"node":{"frontmatter":{"path":"/principles","title":"Principles"}}},{"node":{"frontmatter":{"path":"/software-engineering-checklist","title":"Software Engineering Checklist"}}},{"node":{"frontmatter":{"path":"/security/credentials","title":"Credentials"}}},{"node":{"frontmatter":{"path":"/security/secure-code","title":"Secure Code Standards"}}},{"node":{"frontmatter":{"path":"/security","title":"Security"}}},{"node":{"frontmatter":{"path":"/security/security-training","title":"Security training"}}},{"node":{"frontmatter":{"path":"/security/software-composition","title":"Software Composition Analysis"}}},{"node":{"frontmatter":{"path":"/security/static-code","title":"Static Code Analysis"}}},{"node":{"frontmatter":{"path":"/testing/characteristics","title":"Characteristics of a Good Unit Test"}}},{"node":{"frontmatter":{"path":"/testing/test-data","title":"Test Data"}}},{"node":{"frontmatter":{"path":"/testing/test-driven-checklist","title":"Test-Driven Development Checklist"}}},{"node":{"frontmatter":{"path":"/testing/test-driven-development","title":"Test-Driven Development"}}},{"node":{"frontmatter":{"path":"/testing","title":"Testing"}}},{"node":{"frontmatter":{"path":"/standards/api-standards","title":"API Standards"}}},{"node":{"frontmatter":{"path":"/standards/ci-cd","title":"CI/CD"}}},{"node":{"frontmatter":{"path":"/standards/cloud","title":"Cloud"}}},{"node":{"frontmatter":{"path":"/standards/code-review","title":"Code Review/Pull Requests"}}},{"node":{"frontmatter":{"path":"/standards/code-style","title":"Code Style"}}},{"node":{"frontmatter":{"path":"/standards/definitions","title":"Definitions of Done"}}},{"node":{"frontmatter":{"path":"/standards/design-principles","title":"Design Principles"}}},{"node":{"frontmatter":{"path":"/standards/logging","title":"Logging"}}},{"node":{"frontmatter":{"path":"/standards/ready","title":"Definitions of Ready"}}},{"node":{"frontmatter":{"path":"/standards/readme","title":"README"}}},{"node":{"frontmatter":{"path":"/standards","title":"Standards"}}},{"node":{"frontmatter":{"path":"/standards/design-review","title":"Technical Design Review"}}},{"node":{"frontmatter":{"path":"/standards/version-control","title":"Version Control"}}},{"node":{"frontmatter":{"path":"/standards/versioning","title":"Versioning"}}}]},"markdownRemark":{"html":"<h1>Confluence</h1>\n<p>Confluence should be used for all technical documentation.</p>\n<h2>User Stories</h2>\n<p>User Stories are business requirements, told from a user's point of\nview, and representing business value. They describe something a user\nwould like to achieve or a problem they want to solve.</p>\n<h3>How to write good user stories</h3>\n<p>We believe in conversation over documentation, but user stories have\nminimum requirements:</p>\n<ul>\n<li>\n<p>Acceptance criteria: bullet point list of the requirements</p>\n</li>\n<li>\n<p>Imagery: Attached image or link where appropriate</p>\n</li>\n</ul>\n<p>For more complex stories:</p>\n<ul>\n<li>\n<p>Scenarios: good and bad scenarios of what the user/system is</p>\n<blockquote>\n<p>supposed to perform</p>\n</blockquote>\n</li>\n</ul>\n<p>A good user story should be:</p>\n<ul>\n<li>\n<p>Business focused - A story should be written in terminology that the</p>\n<blockquote>\n<p>business understands; it must return business value.</p>\n</blockquote>\n</li>\n<li>\n<p>Elevatory friendly - A story is a placeholder for a more detailed</p>\n<blockquote>\n<p>conversation, not a feature spec or requirements doc. You should\nbe able to explain the story on a 30 second elevator ride.</p>\n</blockquote>\n</li>\n<li>\n<p>Testable - A story should be testable - if you can't test it you</p>\n<blockquote>\n<p>shouldn't build it</p>\n</blockquote>\n</li>\n</ul>\n<p>**Note: A user story should take no more than 20 minutes to write. **</p>\n<h4>Acceptance Criteria</h4>\n<p>Acceptance Criteria are a set of statements, each with a clear pass/fail\nresult, that specify both functional (e.g., minimal marketable\nfunctionality) and non-functional (e.g., minimal quality) requirements\napplicable. They should be high-level while still providing enough\ndetail to be useful. They should include:</p>\n<ul>\n<li>\n<p><strong>Functional Criteria:</strong> Identify specific user tasks, functions or</p>\n<blockquote>\n<p>business processes that must be in place. A functional criterion\nmight be \"A user is able to access a list of available reports.\" A\nnon-functional criterion might be \"Edit buttons and Workflow\nbuttons comply with the Site Button Design.\"</p>\n</blockquote>\n</li>\n<li>\n<p>**Non-functional Criteria: **Identify specific non-functional</p>\n<blockquote>\n<p>conditions the implementation must meet, such as design elements.\nA non-functional criterion might be \"Edit buttons and Workflow\nbuttons comply with the Site Button Design.\"</p>\n</blockquote>\n</li>\n<li>\n<p>**Performance Criteria: **If specific performance is critical to the</p>\n<blockquote>\n<p>acceptance of a user story, it should be included. This is often\nmeasured as a response time, and should be spelled out as a\nthreshold</p>\n</blockquote>\n</li>\n</ul>\n<p>Acceptance Criteria should state intent, but not a solution (e.g., \"A\nmanager can approve or disapprove an audit form\" rather than \"A manager\ncan click an 'Approve/Disapprove' radio button to approve an audit\nform\"). The criteria should be independent of the implementation:\nideally the phrasing should be the same regardless of target platform.</p>\n<p>**Example: **</p>\n<ul>\n<li>\n<p>Customer can enter coupon code at the payment stage</p>\n</li>\n<li>\n<p>Coupon code will adjust price either by $$ or %</p>\n</li>\n<li>\n<p>Customer can pay by the new discounted amount</p>\n</li>\n</ul>\n<h4>Scenarios</h4>\n<p>A scenario describes the steps necessary to test a story, bug or tech\ndebt. Stories, bugs and tech debt should include multiple scenarios both\nthe happy path and alternate paths. It is equally important to describe\n\"happy-day\" scenarios as well as \"bad-day\" scenarios where\nunexpected user or system behaviour occur.</p>\n<p>The essential idea is to break down writing a scenario (or test) into\nthree sections:</p>\n<ul>\n<li>\n<p>The <strong>Given</strong> part describes the state of the world before you begin</p>\n<blockquote>\n<p>the behaviour you're specifying in this scenario. You can think\nof it as the pre-conditions to the test.</p>\n</blockquote>\n</li>\n<li>\n<p>The <strong>When</strong> section is that behaviour that you're specifying.</p>\n</li>\n<li>\n<p>Finally the <strong>Then</strong> section describes the changes you expect due to</p>\n<blockquote>\n<p>the specified behaviour.</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Scenario 1: Title</strong></p>\n<p>Given [context]</p>\n<p>1. And [:some more context]...</p>\n<p>2. When [event]</p>\n<p>3. Then [:outcome]</p>\n<p>4. And [another outcome]...</p>\n<p>**Example: **</p>\n<p><strong>Scenario: Happy-day</strong><br>\nGiven when a Customer has a coupon code at the payment stage, <br>\nWhen the code entered is correct And within Expire Then apply discount <br>\nWhen the code entered is incorrect or expired Then show error message</p>\n<p><strong>Scenario: Campaign expired (bad-day)</strong><br>\nGiven when a Customer has a coupon code at the payment stage, <br>\nWhen the code entered is correct And the campaign date &#x3C; TODAY Then\nshow error message</p>\n<p><strong>Scenario: Negative payment value (bad-day)</strong><br>\nGiven when a Customer has a coupon code at the assign task stage, <br>\nWhen the discount is below fare value Then credit to zero but not\nnegative.</p>\n<p>The Given, When, Then syntax is useful for testing purposes but not\nmandatory. If you prefer a more storytelling scenario format that\ndepicts the intention of the feature, then by all means write in that\nformat.</p>","frontmatter":{"title":"Confluence","path":"/agile/confluence"}},"allNavYaml":{"edges":[{"node":{"title":"Purpose","id":"purpose","items":null}},{"node":{"title":"Conventions Used","id":"conventions","items":null}},{"node":{"title":"Agile","id":"agile","items":[{"id":"bugs","title":"Bugs"},{"id":"confluence","title":"Confluence"},{"id":"jira","title":"Jira"}]}},{"node":{"title":"Principles","id":"principles","items":null}},{"node":{"title":"Standards","id":"standards","items":[{"id":"definitions","title":"Definitions of Done"},{"id":"ready","title":"Definitions of Ready"},{"id":"version-control","title":"Version Control"},{"id":"code-review","title":"Code Review/Pull Requests"},{"id":"design-review","title":"Technical Design Review"},{"id":"code-style","title":"Code Style"},{"id":"design-principles","title":"Design Principles"},{"id":"cloud","title":"Cloud"},{"id":"ci-cd","title":"CI/CD"},{"id":"versioning","title":"Versioning"},{"id":"api-standards","title":"API Standards"},{"id":"logging","title":"Logging"},{"id":"readme","title":"README"}]}},{"node":{"title":"Design Implementations","id":"design-implementations","items":[{"id":"application-info","title":"Application Info"}]}},{"node":{"title":"Security","id":"security","items":[{"id":"secure-code","title":"Secure Code Standards"},{"id":"static-code","title":"Static Code Analysis"},{"id":"software-composition","title":"Software Composition Analysis"},{"id":"credentials","title":"Credentials"},{"id":"security-training","title":"Security training"}]}},{"node":{"title":"Testing","id":"testing","items":[{"id":"test-driven-development","title":"Test-Driven Development"},{"id":"characteristics","title":"Characteristics of a Good Unit Test"},{"id":"test-driven-checklist","title":"Test-Driven Development Checklist"},{"id":"test-data","title":"Test Data"}]}},{"node":{"title":"Operational Excellence","id":"operational-excellence","items":[{"id":"ceremonies","title":"Ceremonies"},{"id":"standups","title":"Stand-ups"},{"id":"guilds","title":"Guilds"}]}},{"node":{"title":"People","id":"people","items":null}},{"node":{"title":"Software Engineering Checklist","id":"software-engineering-checklist","items":null}}]}},"pageContext":{"section":"playbook"}}